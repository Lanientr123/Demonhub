local _1l1 = game:GetService("Players").LocalPlayer
local _clock = os.clock
local _wait = task.wait
local _char = string.char

local function _v7()
    local _env = getfenv()
    setmetatable(_env, {
        __index = function() return nil end,
        __metatable = "0x" .. math.random(1e3, 9e3)
    })
end
pcall(_v7)

local _dat = {}
for i = 1, 40 do _dat[i] = math.random(1e5, 1e7) end

local _t = _clock()
task.spawn(function()
    while _wait(4) do
        local _c = _clock()
        if (_c - _t) > 8 then 
            _1l1:Kick("Critical Execution Error")
        end
        _t = _c
    end
end)

local _0x1 = false
local _0x2 = false

task.spawn(function()
    while _wait(2) do
        if _0x1 or _0x2 or #_dat < 40 then
            _1l1:Kick("Unauthorized override")
            while true do end
        end
    end
end)

local function _decode_internal(d)
    local _k = 55
    local _res = ""
    for i = 1, #d do _res = _res .. _char(d[i] - _k) end
    return _res
end

print("System: Verified")

setthreadidentity(2)
local router = require(game:GetService("ReplicatedStorage").ClientModules.Core.RouterClient.RouterClient)
local cd = require(game:GetService("ReplicatedStorage").ClientModules.Core.ClientData)
local furnituresdb = require(game:GetService("ReplicatedStorage").ClientDB.Housing.FurnitureDB)
local texturesdb = require(game:GetService("ReplicatedStorage").ClientDB.Housing.TexturesDB)
local plr = game:GetService("Players").LocalPlayer

setthreadidentity(8)
local le = loadstring(game:HttpGet("https://raw.githubusercontent.com/Lanientr123/DemonHubfre/refs/heads/main/XbMrXhAU.txt"))()
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
local Window = Rayfield:CreateWindow({
   Name = "DemonHub | House Cloner",
   Icon = 0,
   LoadingTitle = "Premium",
   LoadingSubtitle = "by DemonHub",
   Theme = "Default",
   DisableRayfieldPrompts = false,
   DisableBuildWarnings = false,
   ConfigurationSaving = {
      Enabled = false,
      FolderName = nil,
      FileName = "Big Hub"
   },
   Discord = {
      Enabled = false,
      Invite = "noinvitelink",
      RememberJoins = true
   },
   KeySystem = false,
   KeySettings = {
      Title = "HouseCloner",
      Subtitle = "Key System",
      Note = "purchase the script! here discord.gg/W9nra95Dvc",
      FileName = "Key",
      SaveKey = true,
      GrabKeyFromSite = false,
      Key = {"QhUeFjxwTAgbYVzLCokSnrMdiWpluZ"}
   }
})
if not isfolder("Savedhouses") then 
    makefolder("Savedhouses") 
end
local Tab = Window:CreateTab("Main", "home")
local fcount = Tab:CreateLabel("Furnitures count: 0", "sofa", _, false)
local fcost = Tab:CreateLabel("Furnitures cost: 0", "dollar-sign", _, false) -- Title, Icon, Color, IgnoreTheme
local tcost = Tab:CreateLabel("Textures cost: 0", "brick-wall", _, false) -- Title, Icon, Color, IgnoreTheme
local progress = Tab:CreateLabel("Progress: 0%", "percent", _, false)
local housedb = require(game:GetService("ReplicatedStorage").ClientDB.Housing.HouseDB)
local function loadinterior(interiortype, teleport, name) --in case you try to load a house then name is an instance (plr)
    setthreadidentity(2)
    local load = require(game:GetService("ReplicatedStorage").Fsys).load
    local interiors = load("InteriorsM")
    local enter = interiors.enter
    if interiortype == "interior" then 
        getgenv().teleport = teleport
        enter(name, "", {})
        return
    end
    if interiortype == "house" then 
        getgenv().teleport = teleport
        enter("housing", "MainDoor", {house_owner = name})
    end
    setthreadidentity(8)
end
local function setcosts(furncount, furncost, textcost)
	fcount:Set(tostring("Furnitures count: "..tostring(furncount)), "sofa", _, false)
    fcost:Set(tostring("Furnitures cost: "..tostring(furncost)), "dollar-sign", _, false)
    tcost:Set(tostring("Textures cost: "..tostring(textcost)), "brick-wall", _, false)
end
local function updateprogress(percent)
    progress:Set(tostring("Progress: "..tostring(percent).."%"), "percent", _, false)
end
local function gethousesoftype(housetype)
	local t = {}
	for i, v in listfiles("Savedhouses") do
		if readfile(v) == "" then
			if housetype == "micro_2023" then
				table.insert(t,v)--empty files are inside of micro_2023
			end
			continue
		end
		local str = readfile(v)
		if not str:find("building_type") then continue end
		if str:sub(str:find("building_type")+15, str:find(",", str:find("building_type"))-2) == housetype then
			table.insert(t,v)
		end
	end
	return t
end
local housetypes = {}
for i,v in pairs(housedb) do
	table.insert(housetypes,i)
end
local filename 
Tab:CreateLabel("Pick your House to Load the file", "info")
local housetype = Tab:CreateDropdown({
    Name = "Select house type",
    Options = housetypes,
    CurrentOption = {"micro_2023"},
    MultipleOptions = false,
    Flag = "ignore",
    Callback = function(Options)
		-- ensure we pass the first selected string
		local sel = Options and Options[1] or housetype.CurrentOption and housetype.CurrentOption[1]
		filename:Refresh(gethousesoftype(sel))
    end,
})
filename = Tab:CreateDropdown({
    Name = "Select house",
    Options = gethousesoftype(housetype.CurrentOption[1]),
    CurrentOption = (gethousesoftype(housetype.CurrentOption[1])[1] and {gethousesoftype(housetype.CurrentOption[1])[1]}),
    MultipleOptions = false,
    Flag = "filename",
    Callback = function(Options)
    end,
})
 local refreshFilesButton = Tab:CreateButton({
    Name = "Refresh files",
    Callback = function()
        local selType = housetype.CurrentOption and housetype.CurrentOption[1] or "micro_2023"
        local files = gethousesoftype(selType)
        filename:Refresh(files)
        Rayfield:Notify({
            Title = "Files Refreshed",
            Content = "Savedhouses list updated for: "..tostring(selType),
            Duration = 3,
            Image = "circle-check",
        })
    end
})
local copyhousetofile = Tab:CreateButton({
    Name = "Save house to file",
    Callback = function()
    setthreadidentity(7)
    local house = loadstring("return "..le(cd.get("house_interior")))()
    if house.player == nil then
        Rayfield:Notify({
            Title = "Error",
            Content = "You need to enter a house to copy",
            Duration = 3,
            Image = "circle-alert",
        })
        return
    end
    for i,v in pairs(house.furniture) do
        if v.creator then v.creator = nil end
    end
    house.player = nil
    writefile(filename.CurrentOption[1], "return "..le(house))
    Rayfield:Notify({
        Title = "Success",
        Content = "Saved house to file",
        Duration = 3,
        Image = "circle-check",
    })
	-- refresh using the currently selected housetype string
	filename:Refresh(gethousesoftype(housetype.CurrentOption[1]))
    end
})
local function countfurnitures(furnitures)
    local count = 0
    for i,v in pairs(furnitures) do
        count+=1
    end
    return count
end
local savedhouse
local loadhousefromfile = Tab:CreateButton({
    Name = "Load house from file",
    Callback = function()
        setthreadidentity(7)
        if not filename.CurrentOption or not filename.CurrentOption[1] then
            return Rayfield:Notify({
                Title = "Error",
                Content = "No file selected",
                Duration = 3,
                Image = "circle-alert",
            })
        end
        local fileContent = readfile(filename.CurrentOption[1])
        if not fileContent or fileContent == "" then
            return Rayfield:Notify({
                Title = "Error",
                Content = "The selected file is empty",
                Duration = 3,
                Image = "circle-alert",
            })
        end
        local success, result = pcall(loadstring(fileContent))
        if not success or type(result) ~= "table" then
            warn(result)
            return Rayfield:Notify({
                Title = "Error",
                Content = "Failed to load house data",
                Duration = 3,
                Image = "circle-alert",
            })
        end
        savedhouse = result
        if not savedhouse or type(savedhouse) ~= "table" then
            return Rayfield:Notify({
                Title = "Error",
                Content = "Invalid house data format",
                Duration = 3,
                Image = "circle-alert",
            })
        end
        local furnitureCost = 0
        if savedhouse.furniture and type(savedhouse.furniture) == "table" then
            for _, item in pairs(savedhouse.furniture) do
                if furnituresdb[item.id] and furnituresdb[item.id].cost then
                    furnitureCost += furnituresdb[item.id].cost
                end
            end
        end
        local textureCost = 0
        if savedhouse.textures and type(savedhouse.textures) == "table" then
            for _, texture in pairs(savedhouse.textures) do
                if texture.walls and texturesdb.walls[texture.walls] and texturesdb.walls[texture.walls].cost then
                    textureCost += texturesdb.walls[texture.walls].cost
                end
                if texture.floors and texturesdb.floors[texture.floors] and texturesdb.floors[texture.floors].cost then
                    textureCost += texturesdb.floors[texture.floors].cost
                end
            end
        end
        task.spawn(setcosts, countfurnitures(savedhouse.furniture), furnitureCost, textureCost)

        Rayfield:Notify({
            Title = "Success",
            Content = "Successfully loaded house from file",
            Duration = 3,
            Image = "circle-check",
        })
    end
})
Tab:CreateLabel("Do not Touch", "info")
local Pastetextures = Tab:CreateToggle({
   Name = "Paste textures",
   CurrentValue = true,
   Flag = "Pastetextures", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)
   end,
})
Tab:CreateSection("Main Function")
local copyhouse = Tab:CreateButton({
    Name = "Scan house",
    Callback = function()
    setthreadidentity(7)
    local house = loadstring("return "..le(cd.get("house_interior")))()
    if house.player == nil then
        Rayfield:Notify({
            Title = "Error",
            Content = "You need to enter a house to copy",
            Duration = 3,
            Image = "circle-alert",
        })
        return
    end
    savedhouse = house
    for i,v in pairs(savedhouse.furniture) do
        if v.creator then v.creator = nil end
    end
    local furniturecost = 0
    for i,v in pairs(savedhouse.furniture) do
        if not furnituresdb[v.id] then
            continue
        end
        furniturecost += furnituresdb[v.id].cost or 0
    end
    local texturecost = 0
    for i,v in pairs(savedhouse.textures) do
        if not texturesdb.walls[v.walls] then
            continue
        end
        texturecost += texturesdb.walls[v.walls].cost or 0
        if not texturesdb.floors[v.floors] then
            continue
        end
        texturecost += texturesdb.floors[v.floors].cost or 0
    end
    task.spawn(setcosts, countfurnitures(savedhouse.furniture), furniturecost, texturecost)
    Rayfield:Notify({
        Title = "Success",
        Content = "Scanned house",
        Duration = 3,
        Image = "circle-check",
    })
    return
    end,
})
local clearhouse = Tab:CreateButton({
    Name = "Sell All Furnitures",
    Callback = function()
        local t = {}
        for i, v in pairs(cd.get("house_interior").furniture) do
            table.insert(t, i)
        end

        local args = {
            false,
            t,
            "sell"
        }
        router.get("HousingAPI/SellFurniture"):FireServer(unpack(args))

        Rayfield:Notify({
            Title = "Success",
            Content = "House cleared successfully!",
            Duration = 3,
            Image = "circle-check",
        })
    end
})
local function canbuyfurniture(kind)
    if furnituresdb[kind] == nil or (furnituresdb[kind] and not furnituresdb[kind].cost) or furnituresdb[kind].off_sale then
        return false, false
    end
    return furnituresdb[kind] and furnituresdb[kind].cost < cd.get_data()[plr.Name].money, true
end
local function textureexists(room, texturetype, texture) --texture is texture id and texturetype is wall or floor
    if texture == "tile" then return true end --tile == no texture
    for i,v in pairs(cd.get("house_interior").textures) do
        if i == room and v[texturetype] == texture then
            return true
        end
    end
    return false
end
local function buytexturewithretry(room, texturetype, texture)
    router.get("HousingAPI/BuyTexture"):FireServer(room, texturetype, texture)
    task.wait(0.05)
    if not textureexists(room, texturetype, texture) then
        warn("couldn't buy texture, retrying")
        buytexturewithretry(room, texturetype, texture)
    end
    print("bought texture: "..texture)
end
local function getfurnitureid(v)
	for a,b in pairs(cd.get("house_interior").furniture) do
		if b.id == v.id and (v.cframe.X == b.cframe.X and v.cframe.Y == b.cframe.Y and v.cframe.Z == b.cframe.Z) and v.scale == b.scale then
			return a
		end
	end
end
local placedfurnitures = {}
local function furnitureexists(kind, properties, furnitureid)
    if placedfurnitures[furnitureid] then return true end
    for i,v in pairs(cd.get("house_interior").furniture) do
        if v.id == kind and (v.cframe.X == properties.cframe.X and v.cframe.Y == properties.cframe.Y and v.cframe.Z == properties.cframe.Z) and v.scale == properties.scale then
            placedfurnitures[furnitureid] = true
            return true
        end
    end
    return false
end
local function buyfurniturewithretry(kind,properties,furnitureid)
    router.get("HousingAPI/BuyFurnitures"):InvokeServer({{kind = kind, properties = properties}})
    task.wait(0.05)
    if not furnitureexists(kind, properties, furnitureid) then
        warn("couldn't buy furniture : "..kind.." retrying")
        buyfurniturewithretry(kind,properties,furnitureid)
    end
    print("[DEBUG] successfully bought furniture: "..kind)
end
local function pastehouseslow()
    placedfurnitures = {}
    local character = game:GetService("Players").LocalPlayer.Character
    local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
    Rayfield:Notify({
        Title = "Loading",
        Content = "Anchoring to prevent falling during paste (glitch houses)",
        Duration = 5,
        Image = "loader",
    })
    if humanoidRootPart then
        humanoidRootPart.Anchored = true
    end
    if not savedhouse or not savedhouse.furniture then
        if humanoidRootPart then
            humanoidRootPart.Anchored = false
        end
        return Rayfield:Notify({
            Title = "Error",
            Content = "No house has been saved",
            Duration = 3,
            Image = "circle-alert",
        })
    end
    Rayfield:Notify({
        Title = "Loading",
        Content = "Pasting furnitures...",
        Duration = 3,
        Image = "loader",
    })
    local validFurniture = {}
    local totalfurnitures = 0
    for i, v in pairs(savedhouse.furniture) do
        if not (string.find(v.id, "lure") and v.id ~= "lures_2023_normal_lure") then
            validFurniture[i] = v
            totalfurnitures += 1
        end
    end
    local processedCount = 0
    for i, v in pairs(validFurniture) do
        local canbuy, exists = canbuyfurniture(v.id)
        if not canbuy and exists == true then
            if humanoidRootPart then
                humanoidRootPart.Anchored = false
            end
            return Rayfield:Notify({
                Title = "Error",
                Content = "Insufficient funds for furniture: "..v.id,
                Duration = 3,
                Image = "circle-alert",
            })
        elseif not canbuy and exists == false then
            processedCount += 1
            continue
        end
        if not furnitureexists(v.id, {colors = v.colors, cframe = v.cframe, scale = v.scale}, i) then
            buyfurniturewithretry(v.id, {colors = v.colors, cframe = v.cframe, scale = v.scale}, i)
        end
        processedCount += 1
        task.spawn(updateprogress, math.floor(processedCount / totalfurnitures * 100))
    end
    for i,v in pairs(cd.get("house_interior").furniture) do --add text
		if v.text then
			router.get("HousingAPI/ActivateFurniture"):InvokeServer(
				plr,
				i,
				"UseBlock",
				v.text,
				plr.Character
			)
		elseif v.outfit_name then
			router.get("AvatarAPI/StartEditingMannequin"):InvokeServer(v.outfit)
			router.get("HousingAPI/ActivateFurniture"):InvokeServer(
				plr,
				i,
				"UseBlock",
				{
					save_outfit = true,
					outfit_name = "Outfit"
				},
				plr.Character
			)
		end
	end

    Rayfield:Notify({
        Title = "Loading",
        Content = "Finished furnitures! Applying walls and floors...",
        Duration = 3,
        Image = "loader",
    })
    if savedhouse.textures and Pastetextures.CurrentValue then
        for roomId, textureData in pairs(savedhouse.textures) do
            if textureData.floors and not textureexists(roomId, "floors", textureData.floors) then
                buytexturewithretry(roomId, "floors", textureData.floors)
            end
            if textureData.walls and not textureexists(roomId, "walls", textureData.walls) then
                buytexturewithretry(roomId, "walls", textureData.walls)
            end
            task.wait()
        end
    end
	if savedhouse.ambiance then
		router.get("AmbianceAPI/UpdateAmbiance"):FireServer(savedhouse.ambiance)
	end
	if savedhouse.music then
		router.get("RadioAPI/Play"):FireServer(
			savedhouse.music.name,
			savedhouse.music.id
		)
		if not savedhouse.music.playing then
			router.get("RadioAPI/Pause"):InvokeServer()
		end
	end
	if humanoidRootPart then
        humanoidRootPart.Anchored = false
    end
    Rayfield:Notify({
        Title = "Success",
        Content = "House Placed successfully!",
        Duration = 3,
        Image = "circle-check",
    })
end

local function pastehouse()
    placedfurnitures = {}
    local character = plr.Character
    local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
    Rayfield:Notify({
        Title = "Loading",
        Content = "Anchoring to prevent falling during paste (glitch houses)",
        Duration = 5,
        Image = "loader",
    })
    if humanoidRootPart then
        humanoidRootPart.Anchored = true
    end
    if not savedhouse or not savedhouse.furniture then
        if humanoidRootPart then
            humanoidRootPart.Anchored = false
        end
        return Rayfield:Notify({
            Title = "Error",
            Content = "No house has been saved",
            Duration = 3,
            Image = "circle-alert",
        })
    end
    Rayfield:Notify({
        Title = "Loading",
        Content = "Pasting furnitures...",
        Duration = 3,
        Image = "loader",
    })
    local validFurniture = {}
    local totalfurnitures = 0
    for i, v in pairs(savedhouse.furniture) do
        if v.id ~= "lures_2023_cozy_home_lure" then
            validFurniture[i] = v
            totalfurnitures += 1
        end
    end
    local processedCount = 0
	local furniturest = {}
    for i, v in pairs(validFurniture) do
        local canbuy, exists = canbuyfurniture(v.id)
        if not canbuy and exists == true then
            if humanoidRootPart then
                humanoidRootPart.Anchored = false
            end
            return Rayfield:Notify({
                Title = "Error",
                Content = "Insufficient funds for furniture: "..v.id,
                Duration = 3,
                Image = "circle-alert",
            })
        elseif not canbuy and exists == false then
            processedCount += 1
            continue
        end
		table.insert(furniturest, {kind = v.id, properties = {colors = v.colors, cframe = v.cframe, scale = v.scale}})
        processedCount += 1
    end
	router.get("HousingAPI/BuyFurnitures"):InvokeServer(furniturest)
	task.spawn(updateprogress, math.floor(processedCount / totalfurnitures * 100))
	for i,v in pairs(cd.get("house_interior").furniture) do --add text
		if v.text then
			router.get("HousingAPI/ActivateFurniture"):InvokeServer(
				plr,
				i,
				"UseBlock",
				v.text,
				plr.Character
			)
		elseif v.outfit_name then
			router.get("AvatarAPI/StartEditingMannequin"):InvokeServer(v.outfit)
			router.get("HousingAPI/ActivateFurniture"):InvokeServer(
				plr,
				i,
				"UseBlock",
				{
					save_outfit = true,
					outfit_name = "Outfit"
				},
				plr.Character
			)
		end
	end

    Rayfield:Notify({
        Title = "Loading",
        Content = "Finished furnitures! Applying walls and floors...",
        Duration = 3,
        Image = "loader",
    })
    if savedhouse.textures and Pastetextures.CurrentValue then
        for roomId, textureData in pairs(savedhouse.textures) do
            if textureData.floors and not textureexists(roomId, "floors", textureData.floors) then
                buytexturewithretry(roomId, "floors", textureData.floors)
            end
            if textureData.walls and not textureexists(roomId, "walls", textureData.walls) then
                buytexturewithretry(roomId, "walls", textureData.walls)
            end
            task.wait()
        end
    end
	if savedhouse.ambiance then
		router.get("AmbianceAPI/UpdateAmbiance"):FireServer(savedhouse.ambiance)
	end
	if savedhouse.music then
		router.get("RadioAPI/Play"):FireServer(
			savedhouse.music.name,
			savedhouse.music.id
		)
		if not savedhouse.music.playing then
			router.get("RadioAPI/Pause"):InvokeServer()
		end
	end
    if humanoidRootPart then
        humanoidRootPart.Anchored = false
    end
    Rayfield:Notify({
        Title = "Success",
        Content = "House Placed successfully!",
        Duration = 3,
        Image = "circle-check",
    })
end
local function pastehouseinit(slow)
    setthreadidentity(8)
        if savedhouse == nil then
            Rayfield:Notify({
                Title = "Error",
                Content = "No house has been saved",
                Duration = 3,
                Image = "circle-alert",
            })
            return
        elseif cd.get("house_interior").player == nil or cd.get("house_interior").player ~= game:GetService("Players").LocalPlayer then
            Rayfield:Notify({
                Title = "Error",
                Content = "Please enter your house to paste the house",
                Duration = 3,
                Image = "circle-alert",
            })
        return
        end
        Rayfield:Notify({
            Title = "Loading",
            Content = "Clearing house",
            Duration = 3,
            Image = "loader",
        })
        for i,v in pairs(cd.get("house_interior").furniture) do
            local args = {
                true,
                {
                    i
                },
                "sell"
            }
            router.get("HousingAPI/SellFurniture"):FireServer(unpack(args))
        end
        task.wait(0.1)
		if slow then
			task.spawn(pastehouseslow)
			return
		end
        task.spawn(pastehouse)
end
local pastehouse = Tab:CreateButton({
    Name = "Place house",
    Callback = pastehouseinit
})
Tab:CreateLabel("Use if you're using Low-end Device", "info")
local pastehouse = Tab:CreateButton({
    Name = "Place house slow",
    Callback = function()
		pastehouseinit(true)
	end
})
local filecreate = Window:CreateTab("Create File", "file")
local newHouseName = filecreate:CreateInput({
    Name = "House name",
    CurrentValue = "",
    PlaceholderText = "Type house name here",
    RemoveTextAfterFocusLost = false,
    Flag = "newHouseName",
    Callback = function() end, -- we'll handle creation with the button
})
local createHouseButton = filecreate:CreateButton({
    Name = "Create House File",
    Callback = function()
        local name = newHouseName.CurrentValue
        if not name or name == "" then
            return Rayfield:Notify({
                Title = "Error",
                Content = "Please enter a valid house name",
                Duration = 3,
                Image = "circle-alert",
            })
        end

        -- Ensure the filename ends with .lua
        if not name:match("%.lua$") then
            if string.find(name, "%.") then
                name = string.split(name, ".")[1]
            end
            name = name .. ".lua"
        end

        local path = "Savedhouses/" .. name

        -- Create the file (empty by default)
        writefile(path, "")

        -- Refresh the dropdown to include the new file
        filename:Refresh(gethousesoftype(housetype.CurrentOption[1]))

        Rayfield:Notify({
            Title = "Success",
            Content = "Created house file: " .. name,
            Duration = 3,
            Image = "circle-check",
        })
    end
})
local Teleport = Window:CreateTab("Teleport", "map-pin")

local function getplayernames()
    local players = game:GetService("Players"):GetPlayers()
    local names = table.create(#players)
    for i, player in ipairs(players) do
        names[i] = player.Name
    end
    return names
end

local selectedplayer = Teleport:CreateDropdown({
    Name = "Select Player",
    Options = getplayernames(),
    CurrentOption = {getplayernames()[1]},
    MultipleOptions = false,
    Flag = "Dropdown1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Options)
    -- The function that takes place when the selected option is changed
    -- The variable (Options) is a table of strings for the current selected options
    end,
})
game:GetService("Players").PlayerAdded:Connect(function(player)
    selectedplayer:Refresh(getplayernames())
end)
game:GetService("Players").PlayerRemoving:Connect(function(player)
    selectedplayer:Refresh(getplayernames())
end)
local teleportbutton = Teleport:CreateButton({
    Name = "Enter House",
    Callback = function()
        loadinterior("house", true, game:GetService("Players")[selectedplayer.CurrentOption[1]])
    end,
})
local others = Window:CreateTab("Others", "circle-ellipsis")
others:CreateSection("Useful tools")

--// Trading License Button
others:CreateButton({
    Name = "Get Trading License",
    Callback = function()
        local Fsys = require(game.ReplicatedStorage:WaitForChild("Fsys")).load
        local Router = Fsys("RouterClient")

        -- Start and complete the trading license process
        Router.get("SettingsAPI/SetBooleanFlag"):FireServer("has_talked_to_trade_quest_npc", true)
        task.wait(0.5)
        Router.get("TradeAPI/BeginQuiz"):FireServer()
        task.wait(1)

        for _, question in pairs(Fsys("ClientData").get("trade_license_quiz_manager").quiz) do
            Router.get("TradeAPI/AnswerQuizQuestion"):FireServer(question.answer)
            task.wait(0.1)
        end

        -- Show success notification
        Rayfield:Notify({
            Title = "Trading License",
            Content = "Successfully obtained your Trading License!",
            Duration = 5,
            Image = "circle-check",
        })
    end
})

others:CreateSection("You don't need to find it anymore")
others:CreateButton({
    Name = "Sell All Lurebox Furniture",
    Callback = function()
        Rayfield:Notify({
            Title = "Loading",
            Content = "Attempting to sell all Lurebox furniture...",
            Duration = 4,
            Image = "loader",
        })

        task.spawn(function()
            pcall(function() setthreadidentity(7) end)
            repeat task.wait() until game:IsLoaded()

            local rs = game:GetService("ReplicatedStorage")
            local Players = game:GetService("Players")
            local plr = Players.LocalPlayer

            local router, cd, furnituresdb
            local ok, err

            ok, err = pcall(function()
                router = require(rs.ClientModules.Core.RouterClient.RouterClient)
            end)
            if not ok then
                Rayfield:Notify({
                    Title = "Error",
                    Content = "Failed to require RouterClient",
                    Duration = 5,
                    Image = "circle-alert",
                })
                return
            end

            ok, err = pcall(function()
                cd = require(rs.ClientModules.Core.ClientData)
            end)
            if not ok then
                Rayfield:Notify({
                    Title = "Error",
                    Content = "Failed to require ClientData",
                    Duration = 5,
                    Image = "circle-alert",
                })
                return
            end

            ok, err = pcall(function()
                furnituresdb = require(rs.ClientDB.Housing.FurnitureDB)
            end)
            if not ok then
                Rayfield:Notify({
                    Title = "Error",
                    Content = "Failed to require FurnitureDB",
                    Duration = 5,
                    Image = "circle-alert",
                })
                return
            end

            -- Wait for house data
            local interior
            local waited = 0
            repeat
                task.wait(0.1)
                interior = cd.get and cd.get("house_interior")
                waited += 1
            until (interior and interior.furniture) or waited >= 100

            if not interior or not interior.furniture then
                Rayfield:Notify({
                    Title = "Error",
                    Content = "No house/furniture found. Enter your house first.",
                    Duration = 6,
                    Image = "circle-alert",
                })
                return
            end

            if interior.player ~= plr then
                Rayfield:Notify({
                    Title = "Error",
                    Content = "You are not inside your own house.",
                    Duration = 6,
                    Image = "circle-alert",
                })
                return
            end

            local exact, anylure = {}, {}
            for idx, fdata in pairs(interior.furniture) do
                local idStr = tostring(fdata.id or ""):lower()
                local nameStr = (furnituresdb[fdata.id] and furnituresdb[fdata.id].name or ""):lower()

                if idStr:find("lurebox") or nameStr:find("lurebox") then
                    table.insert(exact, idx)
                elseif idStr:find("lure") or nameStr:find("lure") then
                    table.insert(anylure, idx)
                end
            end

            local targetList = (#exact > 0) and exact or anylure
            if #targetList == 0 then
                Rayfield:Notify({
                    Title = "Error",
                    Content = "No Lurebox furniture found.",
                    Duration = 5,
                    Image = "circle-alert",
                })
                return
            end

            local function stillExists(indices)
                local cur = cd.get("house_interior")
                if not cur or not cur.furniture then return false end
                for _, i in ipairs(indices) do
                    if cur.furniture[i] then return true end
                end
                return false
            end

            local function trySell(flag, indices)
                local success = pcall(function()
                    router.get("HousingAPI/SellFurniture"):FireServer(flag, indices, "sell")
                end)
                if not success then return false end
                local t = 0
                while t < 3 do
                    task.wait(0.2)
                    t += 0.2
                    if not stillExists(indices) then return true end
                end
                return not stillExists(indices)
            end

            if trySell(true, targetList) or trySell(false, targetList) then
                Rayfield:Notify({
                    Title = "Success",
                    Content = "Successfully sold all lure furniture!",
                    Duration = 5,
                    Image = "circle-check",
                })
                return
            end

            -- fallback: single sells
            local soldCount = 0
            for _, idx in ipairs(targetList) do
                local ok1 = pcall(function()
                    router.get("HousingAPI/SellFurniture"):FireServer(true, {idx}, "sell")
                end)
                task.wait(0.25)
                if not cd.get("house_interior").furniture[idx] then
                    soldCount += 1
                else
                    pcall(function()
                        router.get("HousingAPI/SellFurniture"):FireServer(false, {idx}, "sell")
                    end)
                    task.wait(0.25)
                    if not cd.get("house_interior").furniture[idx] then
                        soldCount += 1
                    end
                end
            end

            if soldCount > 0 then
                Rayfield:Notify({
                    Title = "Success",
                    Content = "Finished! Sold " .. soldCount .. " lure items.",
                    Duration = 6,
                    Image = "circle-check",
                })
            else
                Rayfield:Notify({
                    Title = "Error",
                    Content = "No items sold. Possibly protected or server denied.",
                    Duration = 6,
                    Image = "circle-alert",
                })
            end
        end)
    end,
})
local settings = Window:CreateTab("Settings", "settings")
settings:CreateSection("Player Options")

--// Player Sliders
local Player = game.Players.LocalPlayer
local Character = Player.Character or Player.CharacterAdded:Wait()
local Humanoid = Character:WaitForChild("Humanoid")

-- WalkSpeed Slider
local SpeedSlider = settings:CreateSlider({
	Name = "Player Speed",
	Range = {0, 100},
	Increment = 1,
	Suffix = "Speed",
	CurrentValue = Humanoid.WalkSpeed,
	Flag = "SpeedValue",
	Callback = function(Value)
		Humanoid.WalkSpeed = Value
	end,
})

-- JumpPower Slider
local JumpSlider = settings:CreateSlider({
	Name = "Jump Boost",
	Range = {0, 100},
	Increment = 1,
	Suffix = "Jump",
	CurrentValue = Humanoid.JumpPower,
	Flag = "JumpValue",
	Callback = function(Value)
		Humanoid.JumpPower = Value
	end,
})

-- Auto update when respawn
Player.CharacterAdded:Connect(function(Char)
	task.wait(1)
	Humanoid = Char:WaitForChild("Humanoid")
	Humanoid.WalkSpeed = SpeedSlider.CurrentValue
	Humanoid.JumpPower = JumpSlider.CurrentValue
end)
